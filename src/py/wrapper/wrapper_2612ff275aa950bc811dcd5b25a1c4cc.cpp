#include "_linalg.h"



namespace autowig
{

    void method_decorator_81d91164d6115360a1b4c017fc04048a(class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & instance, ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::RealScalar const & param_in_0, const class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & param_out) { instance.setThreshold(param_in_0) = param_out; }
    void method_decorator_2549b76707b5573394ab93d0646ab2ff(class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & instance, enum ::Eigen::Default_t  param_in_0, const class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & param_out) { instance.setThreshold(param_in_0) = param_out; }
    void method_decorator_00afbcdeece65afc84675d532717ff1b(class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & instance, struct ::Eigen::EigenBase< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const & param_in_0, const class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & param_out) { instance.compute(param_in_0) = param_out; }
}

#if defined(_MSC_VER)
    #if (_MSC_VER == 1900)
namespace boost
{
    template <> class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const volatile * get_pointer<class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const volatile >(class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const volatile *c) { return c; }
}
    #endif
#endif



void wrapper_2612ff275aa950bc811dcd5b25a1c4cc()
{

    std::string name_4851a98e848e5c80a7b2f12fcc62fefe = boost::python::extract< std::string >(boost::python::scope().attr("__name__") + ".eigen");
    boost::python::object module_4851a98e848e5c80a7b2f12fcc62fefe(boost::python::handle<  >(boost::python::borrowed(PyImport_AddModule(name_4851a98e848e5c80a7b2f12fcc62fefe.c_str()))));
    boost::python::scope().attr("eigen") = module_4851a98e848e5c80a7b2f12fcc62fefe;
    boost::python::scope scope_4851a98e848e5c80a7b2f12fcc62fefe = module_4851a98e848e5c80a7b2f12fcc62fefe;
    ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::HouseholderSequenceType  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_59f03f70af3a5b6da20f12d18c6598c1)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::householderQ;
    ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::HouseholderSequenceType  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_6475a04c87cf5782bed694d0ff5d5cd8)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::matrixQ;
    ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::MatrixType const & (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_a2ce72d45e3e5a6982a2bbf4c4218719)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::matrixQR;
    ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::MatrixType const & (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_2737ef525db15399b4ba7c53b9c13d5b)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::matrixR;
    ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::PermutationType const & (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_75f5e5fcbf9252e8945bd9fca464b49c)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::colsPermutation;
    double  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_1f87de9006745179b71ad3ea6f65c1b2)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::absDeterminant;
    double  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_d8b6b9e061ea5b6985068f40fc61132b)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::logAbsDeterminant;
    ::Eigen::Index  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_117f833092b65bbab47128cddd529923)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::rank;
    ::Eigen::Index  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_92abffc5ec055e98b3b0d487986e9f27)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::dimensionOfKernel;
    bool  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_8f6d5112e01d5be1a8f2db38d476ad76)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::isInjective;
    bool  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_9c2f83b7311d515faccc95f8e3e0a4ae)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::isSurjective;
    bool  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_e99dd09a2b34567e98784b2f38d83749)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::isInvertible;
    class ::Eigen::Inverse< class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > > const (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_9a3840ab2d4e593b8f4a9c3d068a4545)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::inverse;
    ::Eigen::Index  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_72d029d768d75097a7359f8216b545be)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::rows;
    ::Eigen::Index  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_5d57a53a2c7350d486fd414e5c6405fa)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::cols;
    ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::HCoeffsType const & (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_e8f759350ac2575894cf9a773e9590d5)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::hCoeffs;
    class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_81d91164d6115360a1b4c017fc04048a)(::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::RealScalar const &) = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::setThreshold;
    class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_2549b76707b5573394ab93d0646ab2ff)(enum ::Eigen::Default_t ) = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::setThreshold;
    ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::RealScalar  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_b282b4387de957a48f49f51cd82524c7)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::threshold;
    ::Eigen::Index  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_b93f6542f94457898d61cbcfea57e232)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::nonzeroPivots;
    ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::RealScalar  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_8db625acdb9953979a31ab19e066846a)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::maxPivot;
    enum ::Eigen::ComputationInfo  (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_714d23d02e6c58a8b7f66bf423e8eb1c)() const = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::info;
    class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & (::Eigen::ColPivHouseholderQR< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_00afbcdeece65afc84675d532717ff1b)(struct ::Eigen::EigenBase< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const &) = &::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::compute;
    boost::python::class_< class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >, autowig::Held< class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > >::Type > class_2612ff275aa950bc811dcd5b25a1c4cc("_ColPivHouseholderQR_2612ff275aa950bc811dcd5b25a1c4cc", "", boost::python::no_init);
    class_2612ff275aa950bc811dcd5b25a1c4cc.def(boost::python::init<  >(""));
    class_2612ff275aa950bc811dcd5b25a1c4cc.def(boost::python::init< ::Eigen::Index , ::Eigen::Index  >(""));
    class_2612ff275aa950bc811dcd5b25a1c4cc.def(boost::python::init< class ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const & >(""));
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("householder_q", method_pointer_59f03f70af3a5b6da20f12d18c6598c1, "");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("matrix_q", method_pointer_6475a04c87cf5782bed694d0ff5d5cd8, "");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("matrix_qr", method_pointer_a2ce72d45e3e5a6982a2bbf4c4218719, boost::python::return_value_policy< boost::python::return_by_value >(), ":Returns:\n    a reference to the matrix where the Householder QR decomposition is\n    stored\n\n:Return Type:\n    :cpp:any:`::Eigen::Matrix<` double, -1, -1, 0, -1, -1 >\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("matrix_r", method_pointer_2737ef525db15399b4ba7c53b9c13d5b, boost::python::return_value_policy< boost::python::return_by_value >(), ":Returns:\n    a reference to the matrix where the result Householder QR is stored\n\n:Return Type:\n    :cpp:any:`::Eigen::Matrix<` double, -1, -1, 0, -1, -1 >\n\n.. warning::\n\n    The strict lower part of this matrix contains internal values. Only the\n    upper triangular part should be referenced. To get it, use\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("cols_permutation", method_pointer_75f5e5fcbf9252e8945bd9fca464b49c, boost::python::return_value_policy< boost::python::return_by_value >(), ":Returns:\n    a const reference to the column permutation matrix\n\n:Return Type:\n    :cpp:any:`::Eigen::PermutationMatrix<` -1, -1, int >\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("abs_determinant", method_pointer_1f87de9006745179b71ad3ea6f65c1b2, ":Returns:\n    the absolute value of the determinant of the matrix of which this is the\n    QR decomposition. It has only linear complexity (that is, O(n) where n\n    is the dimension of the square matrix) as the QR decomposition has\n    already been computed.\n\n:Return Type:\n    :cpp:any:`double`\n\n.. note::\n\n    This is only for square matrices.\n\n.. warning::\n\n    a determinant can be very big or small, so for matrices of large enough\n    dimension, there is a risk of overflow/underflow. One way to work around\n    that is to use logAbsDeterminant() instead.\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("log_abs_determinant", method_pointer_d8b6b9e061ea5b6985068f40fc61132b, ":Returns:\n    the natural log of the absolute value of the determinant of the matrix\n    of which this is the QR decomposition. It has only linear complexity\n    (that is, O(n) where n is the dimension of the square matrix) as the QR\n    decomposition has already been computed.\n\n:Return Type:\n    :cpp:any:`double`\n\n.. note::\n\n    This is only for square matrices.\n\n.. note::\n\n    This method is useful to work around the risk of overflow/underflow\n    that's inherent to determinant computation.\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("rank", method_pointer_117f833092b65bbab47128cddd529923, ":Returns:\n    the rank of the matrix of which \\*this is the QR decomposition.\n\n:Return Type:\n    :cpp:any:`long` int\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("dimension_of_kernel", method_pointer_92abffc5ec055e98b3b0d487986e9f27, ":Returns:\n    the dimension of the kernel of the matrix of which \\*this is the QR\n    decomposition.\n\n:Return Type:\n    :cpp:any:`long` int\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("is_injective", method_pointer_8f6d5112e01d5be1a8f2db38d476ad76, ":Returns:\n    true if the matrix of which \\*this is the QR decomposition represents an\n    injective linear map, i.e. has trivial kernel; false otherwise.\n\n:Return Type:\n    :cpp:any:`bool`\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("is_surjective", method_pointer_9c2f83b7311d515faccc95f8e3e0a4ae, ":Returns:\n    true if the matrix of which \\*this is the QR decomposition represents a\n    surjective linear map; false otherwise.\n\n:Return Type:\n    :cpp:any:`bool`\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("is_invertible", method_pointer_e99dd09a2b34567e98784b2f38d83749, ":Returns:\n    true if the matrix of which \\*this is the QR decomposition is\n    invertible.\n\n:Return Type:\n    :cpp:any:`bool`\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("inverse", method_pointer_9a3840ab2d4e593b8f4a9c3d068a4545, ":Returns:\n    the inverse of the matrix of which \\*this is the QR decomposition.\n\n:Return Type:\n    :cpp:any:`::Eigen::Inverse<` class\n    ::Eigen::ColPivHouseholderQR< class ::Eigen::Matrix< double, -1, -1, 0,\n    -1, -1 > > >\n\n.. note::\n\n    If this matrix is not invertible, the returned matrix has undefined\n    coefficients. Use isInvertible() to first determine whether this matrix\n    is invertible.\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("rows", method_pointer_72d029d768d75097a7359f8216b545be, "");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("cols", method_pointer_5d57a53a2c7350d486fd414e5c6405fa, "");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("h_coeffs", method_pointer_e8f759350ac2575894cf9a773e9590d5, boost::python::return_value_policy< boost::python::return_by_value >(), ":Returns:\n    a const reference to the vector of Householder coefficients used to\n    represent the factor :raw-latex:`\\c Q`.\n    \n    For advanced uses only.\n\n:Return Type:\n    :cpp:any:`::Eigen::Matrix<` double, -1, 1, 0, -1, 1 >\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("set_threshold", method_pointer_81d91164d6115360a1b4c017fc04048a, boost::python::return_internal_reference<>(), ":Parameter:\n    `threshold` (:cpp:any:`double`) - The new value to use as the threshold.\n                                      \n                                      A pivot will be considered nonzero if its absolute value is strictly\n                                      greater than $ :raw-latex:`\\vert `pivot\n                                      :raw-latex:`\\vert `:raw-latex:`\\leqslant `threshold\n                                      :raw-latex:`\\times `:raw-latex:`\\vert `maxpivot :raw-latex:`\\vert `$\n                                      where maxpivot is the biggest pivot.\n                                      \n                                      If you want to come back to the default behavior, call\n                                      setThreshold(Default\\_t)\n\n:Return Type:\n    :cpp:any:`::Eigen::ColPivHouseholderQR<` class\n    ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("set_threshold", autowig::method_decorator_81d91164d6115360a1b4c017fc04048a);
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("set_threshold", method_pointer_2549b76707b5573394ab93d0646ab2ff, boost::python::return_internal_reference<>(), ":Parameter:\n    `` (:cpp:enumerator:`::Eigen::Default_t`) - Undocumented\n\n:Return Type:\n    :cpp:any:`::Eigen::ColPivHouseholderQR<` class\n    ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("set_threshold", autowig::method_decorator_2549b76707b5573394ab93d0646ab2ff);
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("threshold", method_pointer_b282b4387de957a48f49f51cd82524c7, ":Return Type:\n    :cpp:any:`double`\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("nonzero_pivots", method_pointer_b93f6542f94457898d61cbcfea57e232, ":Returns:\n    the number of nonzero pivots in the QR decomposition. Here nonzero is\n    meant in the exact sense, not in a fuzzy sense. So that notion isn't\n    really intrinsically interesting, but it is still useful when\n    implementing algorithms.\n\n:Return Type:\n    :cpp:any:`long` int\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("max_pivot", method_pointer_8db625acdb9953979a31ab19e066846a, ":Returns:\n    the absolute value of the biggest pivot, i.e. the biggest diagonal\n    coefficient of R.\n\n:Return Type:\n    :cpp:any:`double`\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("info", method_pointer_714d23d02e6c58a8b7f66bf423e8eb1c, "Reports whether the QR factorization was succesful.\n\n:Returns:\n    :raw-latex:`\\c S`uccess\n\n:Return Type:\n    :cpp:enumerator:`::Eigen::ComputationInfo`\n\n.. note::\n\n    This function always returns :raw-latex:`\\c S`uccess. It is provided for\n    compatibility with other factorization routines.\n\n");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("compute", method_pointer_00afbcdeece65afc84675d532717ff1b, boost::python::return_internal_reference<>(), "");
    class_2612ff275aa950bc811dcd5b25a1c4cc.def("compute", autowig::method_decorator_00afbcdeece65afc84675d532717ff1b);

}
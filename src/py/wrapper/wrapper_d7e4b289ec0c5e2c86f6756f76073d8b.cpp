#include "_linalg.h"



namespace autowig
{

    void method_decorator_4eeb1a45dde858c08e876902e05cc8ac(class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & instance, ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::RealScalar const & param_in_0, const class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & param_out) { instance.setThreshold(param_in_0) = param_out; }
    void method_decorator_ee8ad3adc67256ddadde3db5475dfdb1(class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & instance, enum ::Eigen::Default_t  param_in_0, const class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & param_out) { instance.setThreshold(param_in_0) = param_out; }
}

#if defined(_MSC_VER)
    #if (_MSC_VER == 1900)
namespace boost
{
    template <> class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const volatile * get_pointer<class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const volatile >(class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const volatile *c) { return c; }
}
    #endif
#endif



void wrapper_d7e4b289ec0c5e2c86f6756f76073d8b()
{

    std::string name_4851a98e848e5c80a7b2f12fcc62fefe = boost::python::extract< std::string >(boost::python::scope().attr("__name__") + ".eigen");
    boost::python::object module_4851a98e848e5c80a7b2f12fcc62fefe(boost::python::handle<  >(boost::python::borrowed(PyImport_AddModule(name_4851a98e848e5c80a7b2f12fcc62fefe.c_str()))));
    boost::python::scope().attr("eigen") = module_4851a98e848e5c80a7b2f12fcc62fefe;
    boost::python::scope scope_4851a98e848e5c80a7b2f12fcc62fefe = module_4851a98e848e5c80a7b2f12fcc62fefe;
    ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::MatrixType const & (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_9b6c9bc34ed7581cbbc6e12ca5a40775)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::matrixLU;
    ::Eigen::Index  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_f2008827c6d05579ba85b97c0e8c971f)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::nonzeroPivots;
    ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::RealScalar  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_39ac9046dffe5f69b26712ce3e041cf7)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::maxPivot;
    ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::PermutationPType const & (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_ebd31bfe6eae589ba7467077007ec806)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::permutationP;
    ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::PermutationQType const & (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_2623b31a8b485365a076556eb3db0f0e)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::permutationQ;
    struct ::Eigen::internal::kernel_retval< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > > const (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_9f2f2302e8d759eb9063e6b7cdcd813f)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::kernel;
    struct ::Eigen::internal::image_retval< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > > const (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_037d369003bd5c5cbc8b528358dd6ff8)(::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::MatrixType const &) const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::image;
    ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::RealScalar  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_205e1e4f6e9f5c0297446af3ce6b14e7)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::rcond;
    double  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_7db6e6b07eec520bbf32690eccdb4ce4)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::determinant;
    class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_4eeb1a45dde858c08e876902e05cc8ac)(::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::RealScalar const &) = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::setThreshold;
    class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > & (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_ee8ad3adc67256ddadde3db5475dfdb1)(enum ::Eigen::Default_t ) = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::setThreshold;
    ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::RealScalar  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_d5533978374c56d0ab6636e6b571e5b1)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::threshold;
    ::Eigen::Index  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_ba764ccf891c5930bbcd736b1452b152)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::rank;
    ::Eigen::Index  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_a4ddb27aa1125fca8bf843f9bea9557d)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::dimensionOfKernel;
    bool  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_24b05a74183b567ba6b6a7091dd9bfe7)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::isInjective;
    bool  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_573e49aa04015c20ab4da8d5f7c32306)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::isSurjective;
    bool  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_666a66fdd39e53579d0abbb527d90228)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::isInvertible;
    class ::Eigen::Inverse< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > > const (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_a055c12fd4615a048f1cbf330c807338)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::inverse;
    ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::MatrixType  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_bb92c36ab53858199438156c659fbe7e)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::reconstructedMatrix;
    ::Eigen::Index  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_bfa8f4283a5e5e0c8f7b09615995177b)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::rows;
    ::Eigen::Index  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_dca806b9b7225afdb176d2d96ced1203)() const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::cols;
    class ::Eigen::Solve< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >, class ::Eigen::CwiseBinaryOp< struct ::Eigen::internal::scalar_quotient_op< double, double >, class ::Eigen::CwiseNullaryOp< struct ::Eigen::internal::scalar_constant_op< double >, class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > > const, class ::Eigen::CwiseNullaryOp< struct ::Eigen::internal::scalar_constant_op< double >, class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > const > const > > const (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_2b0584241ff7538fa205ddd650dd5346)(class ::Eigen::MatrixBase< class ::Eigen::CwiseBinaryOp< struct ::Eigen::internal::scalar_quotient_op< double, double >, class ::Eigen::CwiseNullaryOp< struct ::Eigen::internal::scalar_constant_op< double >, class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > > const, class ::Eigen::CwiseNullaryOp< struct ::Eigen::internal::scalar_constant_op< double >, class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > const > const > > const &) const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::solve;
    void  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_2c6e3d6fd4af5b179d49505b31628081)(class ::Eigen::CwiseBinaryOp< struct ::Eigen::internal::scalar_quotient_op< double, double >, class ::Eigen::CwiseNullaryOp< struct ::Eigen::internal::scalar_constant_op< double >, class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > > const, class ::Eigen::CwiseNullaryOp< struct ::Eigen::internal::scalar_constant_op< double >, class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > const > const > const &, class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > &) const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::_solve_impl;
    class ::Eigen::Solve< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >, class ::Eigen::Block< class ::Eigen::CwiseNullaryOp< struct ::Eigen::internal::scalar_identity_op< double >, class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const, -1, 1, false > > const (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_f77d4dd42bef5eea98562cc54a0271bc)(class ::Eigen::MatrixBase< class ::Eigen::Block< class ::Eigen::CwiseNullaryOp< struct ::Eigen::internal::scalar_identity_op< double >, class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const, -1, 1, false > > const &) const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::solve;
    void  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_d5fe1072f4f55bdb83f391c64ed2dc05)(class ::Eigen::Block< class ::Eigen::CwiseNullaryOp< struct ::Eigen::internal::scalar_identity_op< double >, class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const, -1, 1, false > const &, class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > &) const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::_solve_impl;
    class ::Eigen::Solve< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >, class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > > const (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_05ea997aaa4a5d4bbdf6ef9c005acd92)(class ::Eigen::MatrixBase< class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > > const &) const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::solve;
    void  (::Eigen::FullPivLU< ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::*method_pointer_877444aa44f55082b4f87da763f64d07)(class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > const &, class ::Eigen::Matrix< double, -1, 1, 0, -1, 1 > &) const = &::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >::_solve_impl;
    boost::python::class_< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >, autowig::Held< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > >::Type, boost::python::bases< class ::Eigen::SolverBase< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > > > > class_d7e4b289ec0c5e2c86f6756f76073d8b("_FullPivLU_d7e4b289ec0c5e2c86f6756f76073d8b", "", boost::python::no_init);
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def(boost::python::init<  >(""));
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def(boost::python::init< ::Eigen::Index , ::Eigen::Index  >(""));
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def(boost::python::init< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > const & >(""));
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("matrix_lu", method_pointer_9b6c9bc34ed7581cbbc6e12ca5a40775, boost::python::return_value_policy< boost::python::return_by_value >(), ":Returns:\n    the LU decomposition matrix: the upper-triangular part is U, the\n    unit-lower-triangular part is L (at least for square matrices; in the\n    non-square case, special care is needed, see the documentation of class\n    FullPivLU).\n\n:Return Type:\n    :cpp:any:`::Eigen::Matrix<` double, -1, -1, 0, -1, -1 >\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("nonzero_pivots", method_pointer_f2008827c6d05579ba85b97c0e8c971f, ":Returns:\n    the number of nonzero pivots in the LU decomposition. Here nonzero is\n    meant in the exact sense, not in a fuzzy sense. So that notion isn't\n    really intrinsically interesting, but it is still useful when\n    implementing algorithms.\n\n:Return Type:\n    :cpp:any:`long` int\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("max_pivot", method_pointer_39ac9046dffe5f69b26712ce3e041cf7, ":Returns:\n    the absolute value of the biggest pivot, i.e. the biggest diagonal\n    coefficient of U.\n\n:Return Type:\n    :cpp:any:`double`\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("permutation_p", method_pointer_ebd31bfe6eae589ba7467077007ec806, boost::python::return_value_policy< boost::python::return_by_value >(), ":Returns:\n    the permutation matrix P\n\n:Return Type:\n    :cpp:any:`::Eigen::PermutationMatrix<` -1, -1, int >\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("permutation_q", method_pointer_2623b31a8b485365a076556eb3db0f0e, boost::python::return_value_policy< boost::python::return_by_value >(), ":Returns:\n    the permutation matrix Q\n\n:Return Type:\n    :cpp:any:`::Eigen::PermutationMatrix<` -1, -1, int >\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("kernel", method_pointer_9f2f2302e8d759eb9063e6b7cdcd813f, ":Returns:\n    the kernel of the matrix, also called its null-space. The columns of the\n    returned matrix will form a basis of the kernel.\n\n:Return Type:\n    :cpp:any:`::Eigen::internal::kernel_retval<` class\n    ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >\n    >\n\n.. note::\n\n    If the kernel has dimension zero, then the returned matrix is a\n    column-vector filled with zeros.\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n    \n    Example: :raw-latex:`\\include `FullPivLU\\_kernel.cpp Output:\n    :raw-latex:`\\verbinclude `FullPivLU\\_kernel.out\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("image", method_pointer_037d369003bd5c5cbc8b528358dd6ff8, ":Parameter:\n    `originalMatrix` (:cpp:any:`::Eigen::Matrix<` double, -1, -1, 0, -1, -1 >) - the original matrix, of which \\*this is the LU decomposition. The reason\n                                                                                 why it is needed to pass it here, is that this allows a large\n                                                                                 optimization, as otherwise this method would need to reconstruct it from\n                                                                                 the LU decomposition.\n\n:Returns:\n    the image of the matrix, also called its column-space. The columns of\n    the returned matrix will form a basis of the image (column-space).\n\n:Return Type:\n    :cpp:any:`::Eigen::internal::image_retval<` class\n    ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > >\n    >\n\n.. note::\n\n    If the image has dimension zero, then the returned matrix is a\n    column-vector filled with zeros.\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n    \n    Example: :raw-latex:`\\include `FullPivLU\\_image.cpp Output:\n    :raw-latex:`\\verbinclude `FullPivLU\\_image.out\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("rcond", method_pointer_205e1e4f6e9f5c0297446af3ce6b14e7, ":Returns:\n    an estimate of the reciprocal condition number of the matrix of which\n    :raw-latex:`\\c *t`his is the LU decomposition.\n\n:Return Type:\n    :cpp:any:`double`\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("determinant", method_pointer_7db6e6b07eec520bbf32690eccdb4ce4, ":Returns:\n    the determinant of the matrix of which this is the LU decomposition. It\n    has only linear complexity (that is, O(n) where n is the dimension of\n    the square matrix) as the LU decomposition has already been computed.\n\n:Return Type:\n    :cpp:any:`double`\n\n.. note::\n\n    This is only for square matrices.\n\n.. note::\n\n    For fixed-size matrices of size up to 4, MatrixBase::determinant()\n    offers optimized paths.\n\n.. warning::\n\n    a determinant can be very big or small, so for matrices of large enough\n    dimension, there is a risk of overflow/underflow.\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("set_threshold", method_pointer_4eeb1a45dde858c08e876902e05cc8ac, boost::python::return_internal_reference<>(), ":Parameter:\n    `threshold` (:cpp:any:`double`) - The new value to use as the threshold.\n                                      \n                                      A pivot will be considered nonzero if its absolute value is strictly\n                                      greater than $ :raw-latex:`\\vert `pivot\n                                      :raw-latex:`\\vert `:raw-latex:`\\leqslant `threshold\n                                      :raw-latex:`\\times `:raw-latex:`\\vert `maxpivot :raw-latex:`\\vert `$\n                                      where maxpivot is the biggest pivot.\n                                      \n                                      If you want to come back to the default behavior, call\n                                      setThreshold(Default\\_t)\n\n:Return Type:\n    :cpp:any:`::Eigen::FullPivLU<` class ::Eigen::Matrix<\n    double, -1, -1, 0, -1, -1 > >\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("set_threshold", autowig::method_decorator_4eeb1a45dde858c08e876902e05cc8ac);
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("set_threshold", method_pointer_ee8ad3adc67256ddadde3db5475dfdb1, boost::python::return_internal_reference<>(), ":Parameter:\n    `` (:cpp:enumerator:`::Eigen::Default_t`) - Undocumented\n\n:Return Type:\n    :cpp:any:`::Eigen::FullPivLU<` class ::Eigen::Matrix<\n    double, -1, -1, 0, -1, -1 > >\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("set_threshold", autowig::method_decorator_ee8ad3adc67256ddadde3db5475dfdb1);
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("threshold", method_pointer_d5533978374c56d0ab6636e6b571e5b1, ":Return Type:\n    :cpp:any:`double`\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("rank", method_pointer_ba764ccf891c5930bbcd736b1452b152, ":Returns:\n    the rank of the matrix of which \\*this is the LU decomposition.\n\n:Return Type:\n    :cpp:any:`long` int\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("dimension_of_kernel", method_pointer_a4ddb27aa1125fca8bf843f9bea9557d, ":Returns:\n    the dimension of the kernel of the matrix of which \\*this is the LU\n    decomposition.\n\n:Return Type:\n    :cpp:any:`long` int\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("is_injective", method_pointer_24b05a74183b567ba6b6a7091dd9bfe7, ":Returns:\n    true if the matrix of which \\*this is the LU decomposition represents an\n    injective linear map, i.e. has trivial kernel; false otherwise.\n\n:Return Type:\n    :cpp:any:`bool`\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("is_surjective", method_pointer_573e49aa04015c20ab4da8d5f7c32306, ":Returns:\n    true if the matrix of which \\*this is the LU decomposition represents a\n    surjective linear map; false otherwise.\n\n:Return Type:\n    :cpp:any:`bool`\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("is_invertible", method_pointer_666a66fdd39e53579d0abbb527d90228, ":Returns:\n    true if the matrix of which \\*this is the LU decomposition is\n    invertible.\n\n:Return Type:\n    :cpp:any:`bool`\n\n.. note::\n\n    This method has to determine which pivots should be considered nonzero.\n    For that, it uses the threshold value that you can control by calling\n    setThreshold(const RealScalar&).\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("inverse", method_pointer_a055c12fd4615a048f1cbf330c807338, ":Returns:\n    the inverse of the matrix of which \\*this is the LU decomposition.\n\n:Return Type:\n    :cpp:any:`::Eigen::Inverse<` class ::Eigen::FullPivLU<\n    class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > >\n\n.. note::\n\n    If this matrix is not invertible, the returned matrix has undefined\n    coefficients. Use isInvertible() to first determine whether this matrix\n    is invertible.\n\n");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("reconstructed_matrix", method_pointer_bb92c36ab53858199438156c659fbe7e, "");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("rows", method_pointer_bfa8f4283a5e5e0c8f7b09615995177b, "");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("cols", method_pointer_dca806b9b7225afdb176d2d96ced1203, "");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("solve", method_pointer_2b0584241ff7538fa205ddd650dd5346, "");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("solve_impl", method_pointer_2c6e3d6fd4af5b179d49505b31628081, "");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("solve", method_pointer_f77d4dd42bef5eea98562cc54a0271bc, "");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("solve_impl", method_pointer_d5fe1072f4f55bdb83f391c64ed2dc05, "");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("solve", method_pointer_05ea997aaa4a5d4bbdf6ef9c005acd92, "");
    class_d7e4b289ec0c5e2c86f6756f76073d8b.def("solve_impl", method_pointer_877444aa44f55082b4f87da763f64d07, "");

    if(autowig::Held< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > >::is_class)
    {
        boost::python::implicitly_convertible< autowig::Held< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > >::Type, autowig::Held< class ::Eigen::SolverBase< class ::Eigen::FullPivLU< class ::Eigen::Matrix< double, -1, -1, 0, -1, -1 > > > >::Type >();
    }

}